import React, { useState, useRef, useCallback, useEffect } from 'react';
import { VariableSizeGrid as Grid } from 'react-window';
import { Column, GridRow } from './types';
import { ROW_HEIGHT, HEADER_HEIGHT } from './grid-constants';
import { ContextMenu } from './ContextMenu';

interface MainGridViewProps {
  columns: Column[];
  data: GridRow[];
  scrollTop: number;
  scrollLeft: number;
  containerWidth: number;
  containerHeight: number;
  onScroll: (scrollInfo: { scrollTop: number, scrollLeft: number }) => void;
  onCellChange?: (rowId: string, columnId: string, value: any) => void;
  onColumnChange?: (columnId: string, updates: Partial<Column>) => void;
  onColumnsReorder?: (columnIds: string[]) => void;
  onAddColumn?: (afterColumnId: string) => void;
  onDeleteColumn?: (columnId: string) => void;
  onContextMenu?: (columnId: string | null, position?: { x: number, y: number }) => void;
  contextMenuColumn?: string | null;
  contextMenuPosition?: { x: number, y: number } | null;
}

export function MainGridView({
  columns,
  data,
  scrollTop,
  scrollLeft,
  containerWidth,
  containerHeight,
  onScroll,
  onCellChange,
  onColumnChange,
  onColumnsReorder,
  onAddColumn,
  onDeleteColumn,
  onContextMenu,
  contextMenuColumn,
  contextMenuPosition
}: MainGridViewProps) {
  const gridRef = useRef<any>(null);
  const headerRef = useRef<HTMLDivElement>(null);
  const [editingCell, setEditingCell] = useState<{ rowId: string, columnId: string } | null>(null);
  const [columnWidths, setColumnWidths] = useState<number[]>(columns.map(col => col.width));
  
  // Update column widths when columns change
  useEffect(() => {
    // Create a fresh column widths array based on current columns
    // Always ensure each width is a valid number
    const newColumnWidths = columns.map(col => 
      typeof col.width === 'number' && !isNaN(col.width) ? col.width : 180
    );
    setColumnWidths(newColumnWidths);
  }, [columns]);
  
  // Sync headers with grid scrolling
  useEffect(() => {
    if (headerRef.current) {
      // Force integer-based scrolling to eliminate floating point differences
      const exactScrollLeft = Math.floor(scrollLeft);
      headerRef.current.scrollLeft = exactScrollLeft;
      
      // Force redraw to ensure visual synchronization
      headerRef.current.style.transform = 'translateZ(0)';
    }
  }, [scrollLeft]);
  
  // Handle cell click for editing
  const handleCellClick = (rowId: string, columnId: string) => {
    const column = columns.find(col => col.id === columnId);
    if (!column?.editable) return;
    setEditingCell({ rowId, columnId });
  };
  
  // Handle cell value change
  const handleCellChange = (rowId: string, columnId: string, value: any) => {
    setEditingCell(null);
    if (onCellChange) {
      onCellChange(rowId, columnId, value);
    }
  };
  
  // Handle grid scroll event
  const handleGridScroll = ({ scrollLeft, scrollTop }: { scrollLeft: number; scrollTop: number }) => {
    // Force integer-based scrolling
    onScroll({ 
      scrollLeft: Math.floor(scrollLeft), 
      scrollTop: Math.floor(scrollTop) 
    });
  };
  
  // Handle header drag/drop for column reordering
  const handleHeaderDragStart = (e: React.DragEvent, columnId: string) => {
    e.dataTransfer.setData('text/plain', columnId);
  };
  
  const handleHeaderDrop = (e: React.DragEvent, targetColumnId: string) => {
    e.preventDefault();
    const sourceColumnId = e.dataTransfer.getData('text/plain');
    
    if (sourceColumnId === targetColumnId) return;
    
    if (onColumnsReorder) {
      const sourceIndex = columns.findIndex(col => col.id === sourceColumnId);
      const targetIndex = columns.findIndex(col => col.id === targetColumnId);
      
      if (sourceIndex < 0 || targetIndex < 0) return;
      
      const newOrder = [...columns.map(col => col.id)];
      newOrder.splice(sourceIndex, 1);
      newOrder.splice(targetIndex, 0, sourceColumnId);
      
      onColumnsReorder(newOrder);
    }
  };
  
  // Handle header context menu
  const handleHeaderContextMenu = (e: React.MouseEvent, columnId: string) => {
    e.preventDefault();
    e.stopPropagation();
    if (onContextMenu) {
      onContextMenu(columnId, { x: e.clientX, y: e.clientY });
    }
  };
  
  // Handle cell context menu
  const handleCellContextMenu = (e: React.MouseEvent, columnId: string) => {
    e.preventDefault();
    if (onContextMenu) {
      onContextMenu(columnId, { x: e.clientX, y: e.clientY });
    }
  };
  
  // Column width getter
  const getColumnWidth = useCallback((index: number) => {
    // Ensure we always return a valid number, never NaN or undefined
    const width = columnWidths[index];
    // Round to whole pixels to avoid sub-pixel rendering differences
    return Math.floor((width !== undefined && !isNaN(width)) ? width : 180);
  }, [columnWidths]);
  
  // Calculate total grid width
  const totalWidth = columnWidths.reduce((sum, width) => {
    // Ensure we only add valid numbers
    const validWidth = typeof width === 'number' && !isNaN(width) ? width : 180;
    return sum + validWidth;
  }, 0);
  
  // Render edit input based on column type
  const renderEditInput = (row: GridRow, column: Column) => {
    const value = row[column.id];
    
    switch (column.type) {
      case 'number':
      case 'currency':
        return (
          <input
            type="number"
            className="grid-cell-input"
            defaultValue={value as number}
            autoFocus
            onBlur={(e) => handleCellChange(row.id, column.id, e.target.value)}
          />
        );
      case 'date':
        return (
          <input
            type="date"
            className="grid-cell-input"
            defaultValue={value as string}
            autoFocus
            onBlur={(e) => handleCellChange(row.id, column.id, e.target.value)}
          />
        );
      default:
        return (
          <input
            type="text"
            className="grid-cell-input"
            defaultValue={value as string}
            autoFocus
            onBlur={(e) => handleCellChange(row.id, column.id, e.target.value)}
          />
        );
    }
  };
  
  // Format cell value based on column type
  const formatCellValue = (value: any, column: Column, row?: GridRow) => {
    if (value === undefined || value === null) return '';
    
    
    // If the column has a custom render function, use it
    if (column.renderCell && row) {
      return column.renderCell(value, row);
    }
    
    switch (column.type) {
      case 'currency':
        return new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
        }).format(Number(value));
      case 'status':
        return renderStatusPill(value, column.colors || {});
      default:
        return String(value);
    }
  };
  
  // Render status pill
  const renderStatusPill = (value: string, colors: Record<string, string>) => {
    if (!value) return null;
    
    const backgroundColor = colors[value] || '#f3f4f6';
    const isLight = isColorLight(backgroundColor);
    const textColor = isLight ? '#000000' : '#ffffff';
    
    return (
      <span
        className="px-2 py-0.5 rounded-full text-xs font-medium"
        style={{ backgroundColor, color: textColor }}
      >
        {value}
      </span>
    );
  };
  
  // Helper function to determine if color is light
  const isColorLight = (color: string): boolean => {
    const hex = color.replace('#', '');
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness > 128;
  };
  
  // Cell renderer
  const Cell = ({ columnIndex, rowIndex, style }: { columnIndex: number, rowIndex: number, style: React.CSSProperties }) => {
    const row = data[rowIndex];
    if (!row) return null;
    
    const column = columns[columnIndex];
    if (!column) return null;
    
    const cellId = `${row.id}-${column.id}`;
    const isEditing = editingCell?.rowId === row.id && editingCell?.columnId === column.id;
    const value = row[column.id];
    
    return (
      <div
        style={{
          ...style,
          height: ROW_HEIGHT,
          borderBottom: '1px solid #e5e7eb',
          borderRight: '1px solid #e5e7eb',
          boxSizing: 'border-box',
          width: Math.floor(getColumnWidth(columnIndex))
        }}
        className={`grid-cell ${column.id === contextMenuColumn ? 'highlight-column' : ''}`}
        data-cell={cellId}
        onClick={() => handleCellClick(row.id, column.id)}
        onContextMenu={(e) => {
          e.preventDefault();
          e.stopPropagation();
          if (onContextMenu) {
            onContextMenu(column.id, { x: e.clientX, y: e.clientY });
          }
        }}
      >
        {isEditing ? (
          renderEditInput(row, column)
        ) : (
          formatCellValue(value, column, row)
        )}
      </div>
    );
  };
  
  // Context menu actions
  const handleCopyColumn = (columnId: string) => {
    console.log(`Copy column: ${columnId}`);
    if (onContextMenu) onContextMenu(null);
  };
  
  const handlePasteColumn = (columnId: string) => {
    console.log(`Paste into column: ${columnId}`);
    if (onContextMenu) onContextMenu(null);
  };
  
  const handleInsertLeft = (columnId: string) => {
    console.log(`Insert column left of: ${columnId}`);
    const columnIndex = columns.findIndex(col => col.id === columnId);
    if (columnIndex > 0) {
      const prevColumnId = columns[columnIndex - 1].id;
      if (onAddColumn) {
        onAddColumn(prevColumnId);
      }
    }
    if (onContextMenu) onContextMenu(null);
  };
  
  const handleInsertRight = (columnId: string) => {
    console.log(`Insert column right of: ${columnId}`);
    
    // Don't allow adding columns after lastContacted
    if (columnId === 'lastContacted') {
      console.log("Cannot add columns after lastContacted");
      if (onContextMenu) onContextMenu(null);
      return;
    }
    
    const columnIndex = columns.findIndex(col => col.id === columnId);
    const nextColumnId = columnIndex < columns.length - 1 ? columns[columnIndex + 1].id : null;
    
    if (onContextMenu) onContextMenu(null);
    return;
  };
  
  if (onAddColumn) {
    onAddColumn(columnId);
  }
  if (onContextMenu) onContextMenu(null);
};

const handleDeleteColumn = (columnId: string) => {
  console.log(`Delete column: ${columnId}`);
  if (onDeleteColumn) onDeleteColumn(columnId);
  if (onContextMenu) onContextMenu(null);
};

const handleSortAZ = (columnId: string) => {
  console.log(`Sort sheet A-Z by column: ${columnId}`);
  if (onContextMenu) onContextMenu(null);
};

const handleSortZA = (columnId: string) => {
  console.log(`Sort sheet Z-A by column: ${columnId}`);
  if (onContextMenu) onContextMenu(null);
};

return (
  <div className="main-grid-view">
    {/* Header row */}
    <div 
      className="main-grid-header" 
      ref={headerRef}
      style={{ height: HEADER_HEIGHT, overflow: 'hidden' }}
    >
      <div className="grid-header-row" style={{ 
        width: totalWidth, 
        display: 'flex',
        boxSizing: 'border-box' 
      }}>
        {columns.map((column, index) => (
          <div
            key={column.id}
            className={`grid-header-cell ${column.id === contextMenuColumn ? 'highlight-column' : ''}`}
            style={{ 
              width: Math.floor(column.width),
              boxSizing: 'border-box'
            }}
            draggable
            onDragStart={(e) => handleHeaderDragStart(e, column.id)}
            onDragOver={(e) => e.preventDefault()}
            onDrop={(e) => handleHeaderDrop(e, column.id)}
            onContextMenu={(e) => handleHeaderContextMenu(e, column.id)}
          >
            {column.title}
          </div>
        ))}
      </div>
    </div>
    
    {/* Grid body with external scrollbar */}
    <div className="main-grid-body" style={{ position: 'relative', height: `calc(100% - ${HEADER_HEIGHT}px)` }}>
      <div style={{ 
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        paddingRight: '17px', // Add padding for scrollbar
        boxSizing: 'border-box'
      }}>
        <Grid
          ref={gridRef}
          className="data-grid"
          columnCount={columns.length}
          columnWidth={getColumnWidth}
          rowCount={data.length}
          rowHeight={() => ROW_HEIGHT}
          width={containerWidth || 300}
          height={(containerHeight || 300) - HEADER_HEIGHT}
          onScroll={handleGridScroll}
          style={{ 
            overflowX: 'scroll',
            overflowY: 'scroll',
            marginRight: '-17px' // Negate the scrollbar width
          }}
        >
          {Cell}
        </Grid>
      </div>
    </div>
    
    {/* Context Menu */}
    {contextMenuColumn && contextMenuPosition && (
      <ContextMenu
        x={contextMenuPosition.x}
        y={contextMenuPosition.y}
        columnId={contextMenuColumn}
        onClose={() => onContextMenu && onContextMenu(null)}
        onCopy={handleCopyColumn}
        onPaste={handlePasteColumn}
        onInsertLeft={handleInsertLeft}
        onInsertRight={handleInsertRight}
        onDelete={handleDeleteColumn}
        onSortAZ={handleSortAZ}
        onSortZA={handleSortZA}
        isVisible={!!contextMenuColumn}
      />
    )}
  </div>
);
} 