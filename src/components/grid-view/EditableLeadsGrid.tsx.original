import React, { useState, useEffect, useCallback, useRef } from 'react';
import { GridViewContainer } from '@/components/grid-view/GridViewContainer';
import { Column, GridRow } from '@/components/grid-view/types';
import { GridSkeleton } from '@/components/grid-view/GridSkeleton';
import { GridPagination } from './GridPagination';
import { 
  DEFAULT_COLUMN_WIDTH,
  MOBILE_COLUMN_WIDTH,
  ROW_HEIGHT,
  INDEX_COLUMN_WIDTH
} from '@/components/grid-view/grid-constants';
import { Link } from 'react-router-dom';
import { ExternalLink, Loader2 } from 'lucide-react';
import { v4 as uuidv4 } from 'uuid';
import { mockContactsById } from '@/components/stream/sample-data';
import { Button } from '@/components/ui/button';
import { PAGE_SIZE, LEADS_STORAGE_KEY } from '@/constants/grid';
import { useAuth } from '@/contexts/AuthContext';
import { useLeadsRows } from '@/hooks/supabase/use-leads-rows';
import { toast } from '@/components/ui/use-toast';
import { useActivity } from "@/contexts/ActivityContext";

// Constants
const COLUMNS_STORAGE_KEY = 'gridColumns-v1';

// Save columns to localStorage
const saveColumnsToLocal = (columns: Column[]): void => {
  try {
    localStorage.setItem(COLUMNS_STORAGE_KEY, JSON.stringify(columns));
  } catch (error) {
    console.error('Failed to save columns to localStorage:', error);
  }
};

// Load columns from localStorage
const loadColumnsFromLocal = (): Column[] | null => {
  try {
    const savedColumns = localStorage.getItem(COLUMNS_STORAGE_KEY);
    if (savedColumns) {
      return JSON.parse(savedColumns);
    }
  } catch (error) {
    console.error('Failed to load columns from localStorage:', error);
  }
  return null;
};

// Save columns to Supabase
const saveColumnsToSupabase = async (user: any, columns: Column[]): Promise<void> => {
  if (!user) return;
  
  try {
    const { supabase } = await import('@/integrations/supabase/client');
    const { error } = await supabase
      .from('user_settings')
      .upsert({
        user_id: user.id,
        setting_key: 'grid_columns',
        setting_value: columns,
        updated_at: new Date().toISOString()
      });
    
    if (error) {
      console.error('Failed to save columns to Supabase:', error);
    }
  } catch (error) {
    console.error('Error saving columns to Supabase:', error);
  }
};

// Load columns from Supabase
const loadColumnsFromSupabase = async (user: any): Promise<Column[] | null> => {
  if (!user) return null;
  
  try {
    const { supabase } = await import('@/integrations/supabase/client');
    const { data, error } = await supabase
      .from('user_settings')
      .select('setting_value')
      .eq('user_id', user.id)
      .eq('setting_key', 'grid_columns')
      .single();
    
    if (error || !data) {
      return null;
    }
    
    return data.setting_value as Column[];
  } catch (error) {
    console.error('Error loading columns from Supabase:', error);
    return null;
  }
};

// Sync a row with the mockContactsById mapping
const syncContact = (row: GridRow): void => {
  if (!mockContactsById[row.id]) {
    // Create a new contact object if it doesn't exist
    mockContactsById[row.id] = { 
      id: row.id,
      name: row.name || '',
      email: row.email || '',
    };
  }
  
  // Update the contact object with row values
  mockContactsById[row.id] = {
    ...mockContactsById[row.id],
    name: row.name || '',
    email: row.email || '',
    company: row.company || '',
    owner: row.owner || '',
    status: row.status,
    revenue: row.revenue,
    description: row.description || '',
    jobTitle: row.jobTitle || '', 
    industry: row.industry || '',
    phone: row.phone || '',
    primaryLocation: row.primaryLocation || '',
    facebook: row.facebook || '',
    instagram: row.instagram || '',
    linkedIn: row.linkedin || '',
    twitter: row.twitter || '',
    website: row.website || '',
    associatedDeals: row.associatedDeals || '',
    source: row.source || '',
  };
};

// Create a reusable social link renderer function
const renderSocialLink = (value: any, row: any) => {
  if (!value) return value;
  const url = value.startsWith('http') ? value : `https://${value}`;
  return (
    <div className="flex items-center w-full" onClick={(e) => e.stopPropagation()}>
      <span className="text-[#33B9B0] truncate">{value}</span>
      <a 
        href={url} 
        target="_blank" 
        rel="noopener noreferrer" 
        className="text-[#33B9B0] hover:text-[#2aa39b] ml-1"
        onClick={(e) => {
          e.stopPropagation();
          window.open(url, '_blank');
        }}
      >
        <ExternalLink size={14} />
      </a>
    </div>
  );
};

// Default columns configuration
const getDefaultColumns = (): Column[] => [
  {
    id: 'name',
    title: 'Contact',
      type: 'text',
    width: 180, // Keep contacts column at 180px
      editable: true,
      frozen: true,
      renderCell: (value, row) => (
        <Link to={`/stream-view/${row.id}`} className="text-primary hover:underline">
          {value}
        </Link>
      ),
    },
  {
    id: 'importListName',
    title: 'List Name',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: false,
    },
    {
      id: 'status',
    title: 'Lead Status',
      type: 'status',
      width: DEFAULT_COLUMN_WIDTH,
      editable: true,
      options: ['New', 'In Progress', 'On Hold', 'Closed Won', 'Closed Lost'],
      colors: {
      'New': '#E4E5E8',
      'In Progress': '#DBCDF0',
      'On Hold': '#C6DEF1',
      'Closed Won': '#C9E4DE',
      'Closed Lost': '#F4C6C6',
    },
  },
  {
    id: 'description',
    title: 'Description',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
  },
  {
    id: 'company',
    title: 'Company',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
  },
  {
    id: 'jobTitle',
    title: 'Job Title',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
  },
  {
    id: 'industry',
    title: 'Industry',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
  },
  {
    id: 'phone',
    title: 'Phone',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
  },
  {
    id: 'primaryLocation',
    title: 'Primary Location',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
  },
  {
    id: 'email',
    title: 'Email',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
  },
  {
    id: 'facebook',
    title: 'Facebook',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
    renderCell: renderSocialLink,
  },
  {
    id: 'instagram',
    title: 'Instagram',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
    renderCell: renderSocialLink,
  },
  {
    id: 'linkedin',
    title: 'LinkedIn',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
    renderCell: renderSocialLink,
  },
  {
    id: 'twitter',
    title: 'X',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
    renderCell: renderSocialLink,
  },
  {
    id: 'associatedDeals',
    title: 'Associated Deals',
    type: 'text',
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
  },
    {
      id: 'revenue',
      title: 'Revenue',
      type: 'currency',
      width: DEFAULT_COLUMN_WIDTH,
      editable: true,
    currencyType: 'USD',
    },
    {
      id: 'closeDate',
      title: 'Close Date',
      type: 'date',
      width: DEFAULT_COLUMN_WIDTH,
      editable: true,
    },
    {
      id: 'owner',
      title: 'Owner',
      type: 'text',
      width: DEFAULT_COLUMN_WIDTH,
      editable: true,
    },
    {
    id: 'source',
    title: 'Source',
      type: 'text',
      width: DEFAULT_COLUMN_WIDTH,
      editable: true,
    },
    {
      id: 'lastContacted',
      title: 'Last Contacted',
      type: 'date',
      width: DEFAULT_COLUMN_WIDTH,
    editable: true
  },
];

// Helper function to extract dynamic fields from rows data
const extractDynamicFields = (rows: any[]): Set<string> => {
  const dynamicFields = new Set<string>();
  const standardFields = new Set(getDefaultColumns().map(col => col.id));
  
  rows.forEach(row => {
    // Check fields directly on the row
    Object.keys(row).forEach(key => {
      if (!standardFields.has(key) && key !== 'id' && key !== 'data') {
        dynamicFields.add(key);
      }
    });
    
    // Check fields in the data object
    if (row.data && typeof row.data === 'object') {
      Object.keys(row.data).forEach(key => {
        // Skip internal fields
        if (!key.startsWith('_') && key !== 'account' && key !== 'importedAt') {
          dynamicFields.add(key);
        }
      });
    }
  });
  
  return dynamicFields;
};

// Function to create columns for dynamic fields
const createDynamicColumns = (fields: Set<string>): Column[] => {
  return Array.from(fields).map(field => ({
    id: field,
    title: field.charAt(0).toUpperCase() + field.slice(1).replace(/([A-Z])/g, ' $1').trim(),
    type: 'text' as const,
    width: DEFAULT_COLUMN_WIDTH,
    editable: true,
  }));
};

export function EditableLeadsGrid() {
  // Get authentication state
  const { user } = useAuth();
  const { logCellEdit, logColumnAdd, logColumnDelete, logFilterChange } = useActivity();
    
  // Set up state for grid
  const [isGridReady, setIsGridReady] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  
  // Use our custom hook for leads data
  const { 
    rows, 
    loading, 
    PAGE_SIZE,
    updateCell,
    addContact,
    refreshData
  } = useLeadsRows();
  
  // Set grid ready state when data is loaded
  useEffect(() => {
    if (!loading) {
      setIsGridReady(true);
    }
  }, [loading]);
  
  // Listen for contact-added events to refresh the grid
  useEffect(() => {
    const handleContactAdded = (event: Event) => {
      // Force refresh of the data
      refreshData();
    };

    // Add event listener
    document.addEventListener('contact-added', handleContactAdded);

    // Clean up
    return () => {
      document.removeEventListener('contact-added', handleContactAdded);
    };
  }, [refreshData]);
  
  // Define columns for the grid - start with default columns, then load from storage
  const [columns, setColumns] = useState<Column[]>(getDefaultColumns);

  // Add dynamic columns based on imported data
  useEffect(() => {
    if (rows.length > 0) {
      const dynamicFields = extractDynamicFields(rows);
      const dynamicColumns = createDynamicColumns(dynamicFields);
      
      // Get current column IDs
      const currentColumnIds = new Set(columns.map(col => col.id));
      
      // Only add new dynamic columns that don't already exist
      const newColumns = dynamicColumns.filter(col => !currentColumnIds.has(col.id));
      
      if (newColumns.length > 0) {
        setColumns(prev => [...prev, ...newColumns]);
      }
    }
  }, [rows]);

  // Load columns from storage on component mount
  useEffect(() => {
    const loadStoredColumns = async () => {
      try {
        // First try to load from Supabase if user is authenticated
        let storedColumns: Column[] | null = null;
        
    if (user) {
          storedColumns = await loadColumnsFromSupabase(user);
        }
        
        // If no columns from Supabase, try localStorage
        if (!storedColumns) {
          storedColumns = loadColumnsFromLocal();
        }
        
        // If we found stored columns, use them
        if (storedColumns && storedColumns.length > 0) {
          // Ensure renderCell functions are preserved for social links
          const columnsWithRenderFunctions = storedColumns.map(col => {
            if (['facebook', 'instagram', 'linkedin', 'twitter'].includes(col.id)) {
              return { ...col, renderCell: renderSocialLink };
            }
            if (col.id === 'name') {
              return { 
                ...col, 
                renderCell: (value, row) => (
                  <Link to={`/stream-view/${row.id}`} className="text-primary hover:underline">
                    {value}
                  </Link>
                )
              };
            }
            return col;
          });
          
          setColumns(columnsWithRenderFunctions);
          // Adjust column widths to match the current viewport
          handleResize();
        }
      } catch (error) {
        console.error('Error loading stored columns:', error);
        // Keep default columns on error
      }
    };

    loadStoredColumns();
  }, [user]);

  // State to track hidden columns for unhide functionality
  const [hiddenColumns, setHiddenColumns] = useState<Column[]>([]);

  // Function to save hidden columns to storage
  const saveHiddenColumns = async (hiddenCols: Column[]) => {
    try {
      localStorage.setItem('hiddenColumns-v1', JSON.stringify(hiddenCols));
      
      if (user) {
        const { supabase } = await import('@/integrations/supabase/client');
        await supabase
          .from('user_settings')
          .upsert({
            user_id: user.id,
            setting_key: 'hidden_columns',
            setting_value: hiddenCols,
            updated_at: new Date().toISOString()
          });
      }
    } catch (error) {
      console.error('Failed to save hidden columns:', error);
    }
  };

  // Load hidden columns on mount
  useEffect(() => {
    const loadHiddenColumns = async () => {
      try {
        let storedHiddenColumns: Column[] | null = null;
        
        if (user) {
          const { supabase } = await import('@/integrations/supabase/client');
          const { data } = await supabase
            .from('user_settings')
            .select('setting_value')
            .eq('user_id', user.id)
            .eq('setting_key', 'hidden_columns')
            .single();
          
          if (data) {
            storedHiddenColumns = data.setting_value as Column[];
          }
        }
        
        if (!storedHiddenColumns) {
          const savedHidden = localStorage.getItem('hiddenColumns-v1');
          if (savedHidden) {
            storedHiddenColumns = JSON.parse(savedHidden);
          }
        }
        
        if (storedHiddenColumns) {
          setHiddenColumns(storedHiddenColumns);
        }
      } catch (error) {
        console.error('Error loading hidden columns:', error);
      }
    };

    loadHiddenColumns();
  }, [user]);

  // Function to persist columns to both localStorage and Supabase
  const persistColumns = async (newColumns: Column[]) => {
    // Save to localStorage immediately
    saveColumnsToLocal(newColumns);
    
    // Save to Supabase if user is authenticated
    if (user) {
      await saveColumnsToSupabase(user, newColumns);
    }
  };
  
  // Resize handler extracted so it can be reused
  const handleResize = useCallback(() => {
    const isMobile = window.innerWidth < 768; // Standard mobile breakpoint
    const columnWidth = isMobile ? MOBILE_COLUMN_WIDTH : DEFAULT_COLUMN_WIDTH;

    setColumns(prevColumns =>
      prevColumns.map(col => {
        // On mobile, keep the Contact column at 120px; otherwise use 180px
        if (col.id === 'name') {
          return { ...col, width: isMobile ? 120 : 180 };
        }

        // Update all other columns to use the appropriate width
        return { ...col, width: columnWidth };
      })
    );
  }, []);

  // Add effect to adjust column widths based on screen size
  useEffect(() => {
    handleResize(); // Initial call

    // Add event listener
    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => window.removeEventListener('resize', handleResize);
  }, [handleResize]);
  
  // Handle cell edit
  const handleCellChange = (rowId: string, columnId: string, value: any) => {
    // Find the old value for activity logging
    const row = rows.find(r => r.id === rowId);
    const oldValue = row ? row[columnId] : null;
            
    // Save to Supabase through our hook
    updateCell({ rowId, columnId, value });
        
        // Sync with mockContactsById
    const updatedRow = rows.find(r => r.id === rowId) || { id: rowId };
    updatedRow[columnId] = value;
    syncContact(updatedRow as GridRow);
    
    // Log the activity with contact name if available
    logCellEdit(
      rowId, 
      columnId, 
      value, 
      oldValue
    );
  };
  
  // Handle columns reordering
  const handleColumnsReorder = (columnIds: string[]) => {
    const newColumns = columns.map(col => ({
      ...col,
      order: columnIds.indexOf(col.id)
    })).sort((a, b) => a.order - b.order);
    
    setColumns(newColumns);
    
    // Persist the reordered columns
    persistColumns(newColumns);
    
    // Log the activity
    logFilterChange({ type: 'columns_reorder', columns: columnIds });
  };
  
  // Handle column deletion
  const handleDeleteColumn = (columnId: string) => {
    // Don't delete the primary columns
    if (['name', 'status', 'company'].includes(columnId)) {
      toast({
        title: "Cannot delete primary column",
        description: "This column is required and cannot be removed.",
        variant: "destructive"
      });
      return;
    }
    
    // Log the column deletion
    const column = columns.find(col => col.id === columnId);
    if (column) {
      logColumnDelete(columnId, column.title);
    }
    
    // Remove from columns array
    const newColumns = columns.filter(col => col.id !== columnId);
    setColumns(newColumns);
    
    // Persist the column deletion
    persistColumns(newColumns);
  };
  
  // Handle adding a new column
  const handleAddColumn = (afterColumnId: string) => {
    // Create a new unique column ID
    const columnId = `column-${uuidv4().substring(0, 8)}`;
    
    // Create the new column - defaulting to text type
    const newColumn: Column = {
      id: columnId,
      title: `New Column`,
      type: 'text',
      width: DEFAULT_COLUMN_WIDTH,
      editable: true,
    };
    
    // Find the index where we need to insert
    const afterIndex = columns.findIndex(col => col.id === afterColumnId);
    
    // Log the activity
    logColumnAdd(newColumn.id, newColumn.title);
    
    // Add the column at the right position
    setColumns([
      ...columns.slice(0, afterIndex + 1),
      newColumn,
      ...columns.slice(afterIndex + 1)
    ]);
  };

  // Handle inserting a new column with specific direction and header name
  const handleInsertColumn = (direction: 'left' | 'right', targetIndex: number, headerName: string, columnType: string, config?: any) => {
    // Create a new unique column ID
    const columnId = `column-${uuidv4().substring(0, 8)}`;
    
    // Create the new column with the provided header name and type
    const newColumn: Column = {
      id: columnId,
      title: headerName,
      type: columnType as Column['type'], // Use proper type instead of any
      width: DEFAULT_COLUMN_WIDTH,
      editable: true,
    };

    // Apply configuration based on column type
    if (columnType === 'currency' && config?.currencyType) {
      // Store currency type in the column for formatting
      newColumn.currencyType = config.currencyType;
    } else if (columnType === 'status' && config?.options && config?.colors) {
      // Add status options and colors from config
      newColumn.options = config.options;
      newColumn.colors = config.colors;
    } else if (columnType === 'status') {
      // Default status options if no config provided
      newColumn.options = ['Option 1', 'Option 2', 'Option 3'];
      newColumn.colors = {
        'Option 1': '#E4E5E8',
        'Option 2': '#DBCDF0', 
        'Option 3': '#C6DEF1',
      };
    }
    
    // Calculate insertion index based on direction
    const insertAt = direction === 'left' ? targetIndex : targetIndex + 1;
    
    // Log the activity
    logColumnAdd(newColumn.id, newColumn.title);
    
    // Insert the column at the calculated position
    const newColumns = [
      ...columns.slice(0, insertAt),
      newColumn,
      ...columns.slice(insertAt)
    ];
    
    setColumns(newColumns);
    
    // Persist the new columns configuration
    persistColumns(newColumns);
  };

  // Handle hiding a column (remove from view but don't delete data)
  const handleHideColumn = (columnId: string) => {
    // Log the activity
    const column = columns.find(col => col.id === columnId);
    if (column) {
      logFilterChange({ type: 'column_hidden', columnId, columnName: column.title });
      
      // Store the current index of the column before hiding
      const currentIndex = columns.findIndex(col => col.id === columnId);
      const columnWithIndex = { ...column, originalIndex: currentIndex };
      
      // Add to hidden columns list with original index
      const newHiddenColumns = [...hiddenColumns, columnWithIndex];
      setHiddenColumns(newHiddenColumns);
      saveHiddenColumns(newHiddenColumns);
    }
    
    // Remove from columns array (this hides it from view)
    const newColumns = columns.filter(col => col.id !== columnId);
    setColumns(newColumns);
    
    // Persist the column changes
    persistColumns(newColumns);
  };

  // Handle unhiding a column
  const handleUnhideColumn = (columnId: string) => {
    // Find the column in hidden columns
    const columnToUnhide = hiddenColumns.find(col => col.id === columnId);
    if (!columnToUnhide) return;

    // Restore render functions for social links and contact column
    let restoredColumn = { ...columnToUnhide };
    if (['facebook', 'instagram', 'linkedin', 'twitter'].includes(columnToUnhide.id)) {
      restoredColumn.renderCell = renderSocialLink;
    } else if (columnToUnhide.id === 'name') {
      restoredColumn.renderCell = (value, row) => (
        <Link to={`/stream-view/${row.id}`} className="text-primary hover:underline">
          {value}
        </Link>
      );
    }

    // Remove the originalIndex property as it's not part of the Column interface
    const { originalIndex, ...cleanColumn } = restoredColumn as any;

    // Calculate where to insert the column based on original index
    let insertIndex = originalIndex || 0;
    
    // Adjust the insert index if columns have been removed since hiding
    const currentColumnIds = columns.map(col => col.id);
    const defaultColumnOrder = getDefaultColumns().map(col => col.id);
    
    // Count how many columns that should come before this one are currently visible
    let adjustedIndex = 0;
    for (let i = 0; i < defaultColumnOrder.length && i < originalIndex; i++) {
      const colId = defaultColumnOrder[i];
      if (currentColumnIds.includes(colId)) {
        adjustedIndex++;
      }
    }
    
    // Ensure we don't insert beyond the current array length
    insertIndex = Math.min(adjustedIndex, columns.length);
    
    // Always keep lastContacted at the end if it exists
    const lastContactedIndex = columns.findIndex(col => col.id === 'lastContacted');
    if (lastContactedIndex !== -1 && insertIndex >= lastContactedIndex) {
      insertIndex = lastContactedIndex;
    }
    
    // Insert the column at the calculated position
    const newColumns = [...columns];
    newColumns.splice(insertIndex, 0, cleanColumn);
    
    setColumns(newColumns);
    persistColumns(newColumns);

    // Remove from hidden columns
    const newHiddenColumns = hiddenColumns.filter(col => col.id !== columnId);
    setHiddenColumns(newHiddenColumns);
    saveHiddenColumns(newHiddenColumns);

    // Log the activity
    logFilterChange({ type: 'column_unhidden', columnId, columnName: cleanColumn.title });
  };
  
  // Show better loading UI to cover any potential flash
  if (loading || !isGridReady) {
    return <GridSkeleton rowCount={15} columnCount={10} />;
  }
  
  // Show empty state when there are no rows - GridViewContainer now has its own empty state UI
  if (rows.length === 0) {
    return (
      <div className="flex flex-col h-full">
        {/* Empty state is now handled by GridViewContainer */}
        <GridViewContainer
          columns={columns}
          data={[]}
          listName="Contacts"
          onCellChange={handleCellChange}
          onColumnsReorder={handleColumnsReorder}
          onAddColumn={handleAddColumn}
          onInsertColumn={handleInsertColumn}
          onHideColumn={handleHideColumn}
          onUnhideColumn={handleUnhideColumn}
          hiddenColumns={hiddenColumns}
          searchTerm={searchTerm}
          onSearchChange={setSearchTerm}
        />
      </div>
    );
  }
  
  return (
    <div className="h-full w-full">
      <GridViewContainer 
        columns={columns} 
        data={rows}
        listName="All Leads"
        listType="Lead"
        listId="leads-grid"
        firstRowIndex={0}
        onCellChange={handleCellChange}
        onColumnsReorder={handleColumnsReorder}
        onAddColumn={handleAddColumn}
        onInsertColumn={handleInsertColumn}
        onHideColumn={handleHideColumn}
        onUnhideColumn={handleUnhideColumn}
        hiddenColumns={hiddenColumns}
        onSearchChange={setSearchTerm}
        searchTerm={searchTerm}
        className="h-full"
      />
    </div>
  );
}
